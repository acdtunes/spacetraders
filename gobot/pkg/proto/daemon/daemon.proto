syntax = "proto3";

package daemon;

option go_package = "github.com/andrescamacho/spacetraders-go/pkg/proto/daemon";

// DaemonService defines the gRPC API for CLI <-> Daemon communication
// Communication occurs over Unix domain socket for security and performance
service DaemonService {
  // NavigateShip initiates a ship navigation operation as a background container
  rpc NavigateShip(NavigateShipRequest) returns (NavigateShipResponse);

  // DockShip docks a ship at its current location
  rpc DockShip(DockShipRequest) returns (DockShipResponse);

  // OrbitShip puts a ship into orbit from docked position
  rpc OrbitShip(OrbitShipRequest) returns (OrbitShipResponse);

  // RefuelShip refuels a ship at its current location
  rpc RefuelShip(RefuelShipRequest) returns (RefuelShipResponse);

  // BatchContractWorkflow executes batch contract workflow operations
  rpc BatchContractWorkflow(BatchContractWorkflowRequest) returns (BatchContractWorkflowResponse);

  // ContractFleetCoordinator manages a pool of ships for continuous contract execution
  rpc ContractFleetCoordinator(ContractFleetCoordinatorRequest) returns (ContractFleetCoordinatorResponse);

  // ScoutTour executes market scouting tour operations (single ship)
  rpc ScoutTour(ScoutTourRequest) returns (ScoutTourResponse);

  // ScoutMarkets orchestrates fleet deployment for market scouting (multi-ship with VRP)
  rpc ScoutMarkets(ScoutMarketsRequest) returns (ScoutMarketsResponse);

  // AssignScoutingFleet auto-discovers probe/satellite ships and assigns them to scout markets
  rpc AssignScoutingFleet(AssignScoutingFleetRequest) returns (AssignScoutingFleetResponse);

  // ListContainers returns all running background containers
  rpc ListContainers(ListContainersRequest) returns (ListContainersResponse);

  // GetContainer returns detailed information about a specific container
  rpc GetContainer(GetContainerRequest) returns (GetContainerResponse);

  // StopContainer stops a running background container
  rpc StopContainer(StopContainerRequest) returns (StopContainerResponse);

  // GetContainerLogs retrieves logs from a container
  rpc GetContainerLogs(GetContainerLogsRequest) returns (GetContainerLogsResponse);

  // HealthCheck verifies daemon is running and responsive
  rpc HealthCheck(HealthCheckRequest) returns (HealthCheckResponse);

  // ListShips returns all ships for a player
  rpc ListShips(ListShipsRequest) returns (ListShipsResponse);

  // GetShip returns detailed information about a specific ship
  rpc GetShip(GetShipRequest) returns (GetShipResponse);

  // PurchaseShip purchases a single ship from a shipyard
  rpc PurchaseShip(PurchaseShipRequest) returns (PurchaseShipResponse);

  // BatchPurchaseShips purchases multiple ships from a shipyard as a background operation
  rpc BatchPurchaseShips(BatchPurchaseShipsRequest) returns (BatchPurchaseShipsResponse);

  // GetShipyardListings retrieves available ships at a shipyard
  rpc GetShipyardListings(GetShipyardListingsRequest) returns (GetShipyardListingsResponse);
}

// NavigateShipRequest initiates ship navigation
message NavigateShipRequest {
  // Ship symbol to navigate (e.g., "AGENT-1")
  string ship_symbol = 1;

  // Destination waypoint symbol (e.g., "X1-GZ7-B1")
  string destination = 2;

  // Player ID for authentication
  int32 player_id = 3;

  // Optional agent symbol (alternative to player_id)
  optional string agent_symbol = 4;
}

// NavigateShipResponse returns container ID for tracking
message NavigateShipResponse {
  // Container ID for tracking the navigation operation
  string container_id = 1;

  // Ship symbol
  string ship_symbol = 2;

  // Destination waypoint
  string destination = 3;

  // Initial status
  string status = 4;

  // Estimated total travel time in seconds
  int32 estimated_time_seconds = 5;
}

// DockShipRequest initiates ship docking
message DockShipRequest {
  string ship_symbol = 1;
  int32 player_id = 2;
  optional string agent_symbol = 3;
}

message DockShipResponse {
  string container_id = 1;
  string ship_symbol = 2;
  string status = 3;
}

// OrbitShipRequest initiates ship orbit
message OrbitShipRequest {
  string ship_symbol = 1;
  int32 player_id = 2;
  optional string agent_symbol = 3;
}

message OrbitShipResponse {
  string container_id = 1;
  string ship_symbol = 2;
  string status = 3;
}

// RefuelShipRequest initiates ship refueling
message RefuelShipRequest {
  string ship_symbol = 1;
  int32 player_id = 2;
  optional string agent_symbol = 3;

  // Optional: specific fuel units to purchase. Omit for full tank.
  optional int32 units = 4;
}

message RefuelShipResponse {
  string container_id = 1;
  string ship_symbol = 2;
  int32 fuel_added = 3;
  int32 credits_cost = 4;
  string status = 5;
}

// BatchContractWorkflowRequest initiates batch contract workflow
message BatchContractWorkflowRequest {
  string ship_symbol = 1;
  int32 iterations = 2;
  int32 player_id = 3;
  optional string agent_symbol = 4;
}

message BatchContractWorkflowResponse {
  string container_id = 1;
  string ship_symbol = 2;
  int32 iterations = 3;
  string status = 4;
}

// ContractFleetCoordinatorRequest initiates contract fleet coordination with multiple ships
message ContractFleetCoordinatorRequest {
  repeated string ship_symbols = 1;
  int32 player_id = 2;
  optional string agent_symbol = 3;
}

message ContractFleetCoordinatorResponse {
  string container_id = 1;
  repeated string ship_symbols = 2;
  string status = 3;
}

// ScoutTourRequest initiates market scouting tour
message ScoutTourRequest {
  string ship_symbol = 1;
  repeated string markets = 2;
  int32 iterations = 3;
  int32 player_id = 4;
  optional string agent_symbol = 5;
}

message ScoutTourResponse {
  string container_id = 1;
  string ship_symbol = 2;
  repeated string markets = 3;
  int32 iterations = 4;
  string status = 5;
}

// ScoutMarketsRequest initiates fleet market scouting with VRP optimization
message ScoutMarketsRequest {
  repeated string ship_symbols = 1;
  string system_symbol = 2;
  repeated string markets = 3;
  int32 iterations = 4;
  int32 player_id = 5;
  optional string agent_symbol = 6;
}

message ScoutMarketsResponse {
  repeated string container_ids = 1;
  map<string, MarketAssignment> assignments = 2;
  repeated string reused_containers = 3;
}

// MarketAssignment represents markets assigned to a ship
message MarketAssignment {
  repeated string markets = 1;
}

// AssignScoutingFleetRequest auto-discovers and assigns scouting fleet
message AssignScoutingFleetRequest {
  string system_symbol = 1;
  int32 player_id = 2;
  optional string agent_symbol = 3;
}

message AssignScoutingFleetResponse {
  string container_id = 1; // Fleet-assignment container ID
}

// ListContainersRequest lists all containers
message ListContainersRequest {
  // Optional filter by player ID
  optional int32 player_id = 1;

  // Optional filter by container status
  optional string status = 2;
}

message ListContainersResponse {
  repeated ContainerInfo containers = 1;
}

message ContainerInfo {
  string container_id = 1;
  string container_type = 2;
  string status = 3;
  int32 player_id = 4;
  string created_at = 5;
  string updated_at = 6;

  // Iteration tracking for loops
  int32 current_iteration = 7;
  int32 max_iterations = 8;

  // Restart tracking
  int32 restart_count = 9;
}

// GetContainerRequest retrieves container details
message GetContainerRequest {
  string container_id = 1;
}

message GetContainerResponse {
  ContainerInfo container = 1;
  string metadata = 2; // JSON-encoded metadata
}

// StopContainerRequest stops a container
message StopContainerRequest {
  string container_id = 1;
}

message StopContainerResponse {
  string container_id = 1;
  string status = 2;
  string message = 3;
}

// GetContainerLogsRequest retrieves container logs
message GetContainerLogsRequest {
  string container_id = 1;

  // Optional limit on number of log entries
  optional int32 limit = 2;

  // Optional filter by log level (INFO, WARNING, ERROR, DEBUG)
  optional string level = 3;
}

message GetContainerLogsResponse {
  repeated LogEntry logs = 1;
}

message LogEntry {
  string timestamp = 1;
  string level = 2;
  string message = 3;
  string metadata = 4; // JSON-encoded metadata
}

// HealthCheckRequest verifies daemon status
message HealthCheckRequest {
  // Empty for now
}

message HealthCheckResponse {
  string status = 1; // "ok" or error message
  string version = 2;
  int32 active_containers = 3;
}

// ListShipsRequest lists all ships for a player
message ListShipsRequest {
  // Optional player ID filter
  optional int32 player_id = 1;

  // Optional agent symbol (alternative to player_id)
  optional string agent_symbol = 2;
}

message ListShipsResponse {
  repeated ShipInfo ships = 1;
}

message ShipInfo {
  string symbol = 1;
  string location = 2;
  string nav_status = 3;
  int32 fuel_current = 4;
  int32 fuel_capacity = 5;
  int32 cargo_units = 6;
  int32 cargo_capacity = 7;
  int32 engine_speed = 8;
}

// GetShipRequest retrieves ship details
message GetShipRequest {
  string ship_symbol = 1;
  optional int32 player_id = 2;
  optional string agent_symbol = 3;
}

message GetShipResponse {
  ShipDetail ship = 1;
}

message ShipDetail {
  string symbol = 1;
  string location = 2;
  string nav_status = 3;
  int32 fuel_current = 4;
  int32 fuel_capacity = 5;
  int32 cargo_units = 6;
  int32 cargo_capacity = 7;
  repeated CargoItem cargo_inventory = 8;
  int32 engine_speed = 9;
}

// PurchaseShipRequest requests purchase of a single ship
message PurchaseShipRequest {
  string purchasing_ship_symbol = 1;
  string ship_type = 2;
  int32 player_id = 3;
  optional string agent_symbol = 4;
  optional string shipyard_waypoint = 5; // Optional - will auto-discover if not provided
}

message PurchaseShipResponse {
  string container_id = 1;
  string purchased_ship_symbol = 2;
  int32 purchase_price = 3;
  int32 agent_credits = 4;
  string status = 5;
}

// BatchPurchaseShipsRequest requests batch purchase of multiple ships
message BatchPurchaseShipsRequest {
  string purchasing_ship_symbol = 1;
  string ship_type = 2;
  int32 quantity = 3;
  int32 max_budget = 4;
  int32 player_id = 5;
  optional string agent_symbol = 6;
  optional string shipyard_waypoint = 7; // Optional - will auto-discover if not provided
  optional int32 iterations = 8; // -1 for infinite, default 1
}

message BatchPurchaseShipsResponse {
  string container_id = 1;
  int32 ships_to_purchase = 2;
  int32 max_budget = 3;
  string shipyard_waypoint = 4;
  string status = 5;
}

// GetShipyardListingsRequest requests shipyard listings
message GetShipyardListingsRequest {
  string system_symbol = 1;
  string waypoint_symbol = 2;
  int32 player_id = 3;
  optional string agent_symbol = 4;
}

message GetShipyardListingsResponse {
  repeated ShipListing listings = 1;
  string shipyard_symbol = 2;
  int32 modification_fee = 3;
}

message ShipListing {
  string ship_type = 1;
  string name = 2;
  string description = 3;
  int32 purchase_price = 4;
}

message CargoItem {
  string symbol = 1;
  string name = 2;
  int32 units = 3;
}

syntax = "proto3";

package daemon;

option go_package = "github.com/andrescamacho/spacetraders-go/pkg/proto/daemon";

// DaemonService defines the gRPC API for CLI <-> Daemon communication
// Communication occurs over Unix domain socket for security and performance
service DaemonService {
  // NavigateShip initiates a ship navigation operation as a background container
  rpc NavigateShip(NavigateShipRequest) returns (NavigateShipResponse);

  // DockShip docks a ship at its current location
  rpc DockShip(DockShipRequest) returns (DockShipResponse);

  // OrbitShip puts a ship into orbit from docked position
  rpc OrbitShip(OrbitShipRequest) returns (OrbitShipResponse);

  // RefuelShip refuels a ship at its current location
  rpc RefuelShip(RefuelShipRequest) returns (RefuelShipResponse);

  // JumpShip executes a jump to a different star system via jump gate
  rpc JumpShip(JumpShipRequest) returns (JumpShipResponse);

  // BatchContractWorkflow executes batch contract workflow operations
  rpc BatchContractWorkflow(BatchContractWorkflowRequest) returns (BatchContractWorkflowResponse);

  // ContractFleetCoordinator manages a pool of ships for continuous contract execution
  rpc ContractFleetCoordinator(ContractFleetCoordinatorRequest) returns (ContractFleetCoordinatorResponse);

  // ScoutTour executes market scouting tour operations (single ship)
  rpc ScoutTour(ScoutTourRequest) returns (ScoutTourResponse);

  // ScoutMarkets orchestrates fleet deployment for market scouting (multi-ship with VRP)
  rpc ScoutMarkets(ScoutMarketsRequest) returns (ScoutMarketsResponse);

  // AssignScoutingFleet auto-discovers probe/satellite ships and assigns them to scout markets
  rpc AssignScoutingFleet(AssignScoutingFleetRequest) returns (AssignScoutingFleetResponse);

  // ListContainers returns all running background containers
  rpc ListContainers(ListContainersRequest) returns (ListContainersResponse);

  // GetContainer returns detailed information about a specific container
  rpc GetContainer(GetContainerRequest) returns (GetContainerResponse);

  // StopContainer stops a running background container
  rpc StopContainer(StopContainerRequest) returns (StopContainerResponse);

  // GetContainerLogs retrieves logs from a container
  rpc GetContainerLogs(GetContainerLogsRequest) returns (GetContainerLogsResponse);

  // HealthCheck verifies daemon is running and responsive
  rpc HealthCheck(HealthCheckRequest) returns (HealthCheckResponse);

  // ListShips returns all ships for a player
  rpc ListShips(ListShipsRequest) returns (ListShipsResponse);

  // GetShip returns detailed information about a specific ship
  rpc GetShip(GetShipRequest) returns (GetShipResponse);

  // PurchaseShip purchases a single ship from a shipyard
  rpc PurchaseShip(PurchaseShipRequest) returns (PurchaseShipResponse);

  // BatchPurchaseShips purchases multiple ships from a shipyard as a background operation
  rpc BatchPurchaseShips(BatchPurchaseShipsRequest) returns (BatchPurchaseShipsResponse);

  // GetShipyardListings retrieves available ships at a shipyard
  rpc GetShipyardListings(GetShipyardListingsRequest) returns (GetShipyardListingsResponse);

  // MiningOperation starts a mining operation with Transport-as-Sink pattern
  rpc MiningOperation(MiningOperationRequest) returns (MiningOperationResponse);

  // TourSell executes optimized cargo selling tour for a ship
  rpc TourSell(TourSellRequest) returns (TourSellResponse);

  // StartGoodsFactory initiates automated goods production using supply chain fabrication
  rpc StartGoodsFactory(StartGoodsFactoryRequest) returns (StartGoodsFactoryResponse);

  // StopGoodsFactory stops a running goods factory operation
  rpc StopGoodsFactory(StopGoodsFactoryRequest) returns (StopGoodsFactoryResponse);

  // GetFactoryStatus retrieves status and progress of a goods factory
  rpc GetFactoryStatus(GetFactoryStatusRequest) returns (GetFactoryStatusResponse);
}

// NavigateShipRequest initiates ship navigation
message NavigateShipRequest {
  // Ship symbol to navigate (e.g., "AGENT-1")
  string ship_symbol = 1;

  // Destination waypoint symbol (e.g., "X1-GZ7-B1")
  string destination = 2;

  // Player ID for authentication
  int32 player_id = 3;

  // Optional agent symbol (alternative to player_id)
  optional string agent_symbol = 4;
}

// NavigateShipResponse returns container ID for tracking
message NavigateShipResponse {
  // Container ID for tracking the navigation operation
  string container_id = 1;

  // Ship symbol
  string ship_symbol = 2;

  // Destination waypoint
  string destination = 3;

  // Initial status
  string status = 4;

  // Estimated total travel time in seconds
  int32 estimated_time_seconds = 5;
}

// DockShipRequest initiates ship docking
message DockShipRequest {
  string ship_symbol = 1;
  int32 player_id = 2;
  optional string agent_symbol = 3;
}

message DockShipResponse {
  string container_id = 1;
  string ship_symbol = 2;
  string status = 3;
}

// OrbitShipRequest initiates ship orbit
message OrbitShipRequest {
  string ship_symbol = 1;
  int32 player_id = 2;
  optional string agent_symbol = 3;
}

message OrbitShipResponse {
  string container_id = 1;
  string ship_symbol = 2;
  string status = 3;
}

// RefuelShipRequest initiates ship refueling
message RefuelShipRequest {
  string ship_symbol = 1;
  int32 player_id = 2;
  optional string agent_symbol = 3;

  // Optional: specific fuel units to purchase. Omit for full tank.
  optional int32 units = 4;
}

message RefuelShipResponse {
  string container_id = 1;
  string ship_symbol = 2;
  int32 fuel_added = 3;
  int32 credits_cost = 4;
  string status = 5;
}

// JumpShipRequest initiates a jump to another system
message JumpShipRequest {
  string ship_symbol = 1;
  string destination_system = 2;
  int32 player_id = 3;
  optional string agent_symbol = 4;
}

message JumpShipResponse {
  bool success = 1;
  bool navigated_to_gate = 2;
  string jump_gate_symbol = 3;
  string destination_system = 4;
  int32 cooldown_seconds = 5;
  string message = 6;
  string error = 7;
}

// BatchContractWorkflowRequest initiates batch contract workflow
message BatchContractWorkflowRequest {
  string ship_symbol = 1;
  int32 iterations = 2;
  int32 player_id = 3;
  optional string agent_symbol = 4;
}

message BatchContractWorkflowResponse {
  string container_id = 1;
  string ship_symbol = 2;
  int32 iterations = 3;
  string status = 4;
}

// ContractFleetCoordinatorRequest initiates contract fleet coordination
// Uses all available idle light hauler ships (no pre-assignment needed)
message ContractFleetCoordinatorRequest {
  int32 player_id = 1;
  optional string agent_symbol = 2;
}

message ContractFleetCoordinatorResponse {
  string container_id = 1;
  string status = 2;
}

// ScoutTourRequest initiates market scouting tour
message ScoutTourRequest {
  string ship_symbol = 1;
  repeated string markets = 2;
  int32 iterations = 3;
  int32 player_id = 4;
  optional string agent_symbol = 5;
}

message ScoutTourResponse {
  string container_id = 1;
  string ship_symbol = 2;
  repeated string markets = 3;
  int32 iterations = 4;
  string status = 5;
}

// ScoutMarketsRequest initiates fleet market scouting with VRP optimization
message ScoutMarketsRequest {
  repeated string ship_symbols = 1;
  string system_symbol = 2;
  repeated string markets = 3;
  int32 iterations = 4;
  int32 player_id = 5;
  optional string agent_symbol = 6;
}

message ScoutMarketsResponse {
  repeated string container_ids = 1;
  map<string, MarketAssignment> assignments = 2;
  repeated string reused_containers = 3;
}

// MarketAssignment represents markets assigned to a ship
message MarketAssignment {
  repeated string markets = 1;
}

// AssignScoutingFleetRequest auto-discovers and assigns scouting fleet
message AssignScoutingFleetRequest {
  string system_symbol = 1;
  int32 player_id = 2;
  optional string agent_symbol = 3;
}

message AssignScoutingFleetResponse {
  string container_id = 1; // Fleet-assignment container ID
}

// ListContainersRequest lists all containers
message ListContainersRequest {
  // Optional filter by player ID
  optional int32 player_id = 1;

  // Optional filter by container status
  optional string status = 2;
}

message ListContainersResponse {
  repeated ContainerInfo containers = 1;
}

message ContainerInfo {
  string container_id = 1;
  string container_type = 2;
  string status = 3;
  int32 player_id = 4;
  string created_at = 5;
  string updated_at = 6;

  // Iteration tracking for loops
  int32 current_iteration = 7;
  int32 max_iterations = 8;

  // Restart tracking
  int32 restart_count = 9;
}

// GetContainerRequest retrieves container details
message GetContainerRequest {
  string container_id = 1;
}

message GetContainerResponse {
  ContainerInfo container = 1;
  string metadata = 2; // JSON-encoded metadata
}

// StopContainerRequest stops a container
message StopContainerRequest {
  string container_id = 1;
}

message StopContainerResponse {
  string container_id = 1;
  string status = 2;
  string message = 3;
}

// GetContainerLogsRequest retrieves container logs
message GetContainerLogsRequest {
  string container_id = 1;

  // Optional limit on number of log entries
  optional int32 limit = 2;

  // Optional filter by log level (INFO, WARNING, ERROR, DEBUG)
  optional string level = 3;
}

message GetContainerLogsResponse {
  repeated LogEntry logs = 1;
}

message LogEntry {
  string timestamp = 1;
  string level = 2;
  string message = 3;
  string metadata = 4; // JSON-encoded metadata
}

// HealthCheckRequest verifies daemon status
message HealthCheckRequest {
  // Empty for now
}

message HealthCheckResponse {
  string status = 1; // "ok" or error message
  string version = 2;
  int32 active_containers = 3;
}

// ListShipsRequest lists all ships for a player
message ListShipsRequest {
  // Optional player ID filter
  optional int32 player_id = 1;

  // Optional agent symbol (alternative to player_id)
  optional string agent_symbol = 2;
}

message ListShipsResponse {
  repeated ShipInfo ships = 1;
}

message ShipInfo {
  string symbol = 1;
  string location = 2;
  string nav_status = 3;
  int32 fuel_current = 4;
  int32 fuel_capacity = 5;
  int32 cargo_units = 6;
  int32 cargo_capacity = 7;
  int32 engine_speed = 8;
}

// GetShipRequest retrieves ship details
message GetShipRequest {
  string ship_symbol = 1;
  optional int32 player_id = 2;
  optional string agent_symbol = 3;
}

message GetShipResponse {
  ShipDetail ship = 1;
}

message ShipDetail {
  string symbol = 1;
  string location = 2;
  string nav_status = 3;
  int32 fuel_current = 4;
  int32 fuel_capacity = 5;
  int32 cargo_units = 6;
  int32 cargo_capacity = 7;
  repeated CargoItem cargo_inventory = 8;
  int32 engine_speed = 9;
  string role = 10;
}

// PurchaseShipRequest requests purchase of a single ship
message PurchaseShipRequest {
  string purchasing_ship_symbol = 1;
  string ship_type = 2;
  int32 player_id = 3;
  optional string agent_symbol = 4;
  optional string shipyard_waypoint = 5; // Optional - will auto-discover if not provided
}

message PurchaseShipResponse {
  string container_id = 1;
  string purchased_ship_symbol = 2;
  int32 purchase_price = 3;
  int32 agent_credits = 4;
  string status = 5;
}

// BatchPurchaseShipsRequest requests batch purchase of multiple ships
message BatchPurchaseShipsRequest {
  string purchasing_ship_symbol = 1;
  string ship_type = 2;
  int32 quantity = 3;
  int32 max_budget = 4;
  int32 player_id = 5;
  optional string agent_symbol = 6;
  optional string shipyard_waypoint = 7; // Optional - will auto-discover if not provided
  optional int32 iterations = 8; // -1 for infinite, default 1
}

message BatchPurchaseShipsResponse {
  string container_id = 1;
  int32 ships_to_purchase = 2;
  int32 max_budget = 3;
  string shipyard_waypoint = 4;
  string status = 5;
}

// GetShipyardListingsRequest requests shipyard listings
message GetShipyardListingsRequest {
  string system_symbol = 1;
  string waypoint_symbol = 2;
  int32 player_id = 3;
  optional string agent_symbol = 4;
}

message GetShipyardListingsResponse {
  repeated ShipListing listings = 1;
  string shipyard_symbol = 2;
  int32 modification_fee = 3;
}

message ShipListing {
  string ship_type = 1;
  string name = 2;
  string description = 3;
  int32 purchase_price = 4;
}

message CargoItem {
  string symbol = 1;
  string name = 2;
  int32 units = 3;
}

// MiningOperationRequest starts a mining operation with miners and transports
message MiningOperationRequest {
  optional string asteroid_field = 1; // Optional: specific waypoint, or auto-select based on mining_type
  repeated string miner_ships = 2;    // Ships for mining
  repeated string transport_ships = 3; // Ships for transport
  int32 top_n_ores = 4;               // Number of ore types to keep (default: 3)
  int32 player_id = 5;
  optional string agent_symbol = 6;
  optional string mining_type = 7;    // Type: common_metals, precious_metals, rare_metals, minerals, ice, gas
  bool force = 8;                     // Override fuel validation warnings
  bool dry_run = 9;                   // If true, only select asteroid without starting operation
  int32 max_leg_time = 10;            // Max time per leg in minutes (0 = no limit)
}

message MiningOperationResponse {
  string container_id = 1;
  string asteroid_field = 2;
  repeated string miner_ships = 3;
  repeated string transport_ships = 4;
  string status = 5;
  // Dry-run results
  string market_symbol = 6;              // Market for transport loop
  repeated ShipRoute ship_routes = 7;    // Planned routes for all ships
  repeated string errors = 8;            // Any errors during route planning
}

// RouteSegment represents a single leg of a planned route
message RouteSegment {
  string from = 1;
  string to = 2;
  string flight_mode = 3;  // CRUISE, DRIFT, BURN, STEALTH
  int32 fuel_cost = 4;
  int32 travel_time = 5;   // seconds
}

// ShipRoute contains a ship's planned route
message ShipRoute {
  string ship_symbol = 1;
  string ship_type = 2;    // "miner" or "transport"
  repeated RouteSegment segments = 3;
  int32 total_fuel = 4;
  int32 total_time = 5;    // seconds
}

// TourSellRequest executes optimized cargo selling tour
message TourSellRequest {
  string ship_symbol = 1;
  int32 player_id = 2;
  optional string agent_symbol = 3;
  optional string return_waypoint = 4; // Optional waypoint to return to after selling
}

message TourSellResponse {
  string container_id = 1;
  string ship_symbol = 2;
  string status = 3;
}

message SoldItem {
  string symbol = 1;
  int32 units = 2;
  int32 revenue = 3;
  string market = 4;
}

// StartGoodsFactoryRequest initiates automated goods production
message StartGoodsFactoryRequest {
  int32 player_id = 1;
  string target_good = 2;
  optional string system_symbol = 3; // Optional: defaults to current system
  optional string agent_symbol = 4;
  optional int32 max_iterations = 5; // Optional: -1 for infinite, 0 or unset for single run, >0 for specific count
}

// StartGoodsFactoryResponse returns factory details
message StartGoodsFactoryResponse {
  string factory_id = 1;
  string target_good = 2;
  string status = 3;
  string message = 4; // e.g., "Dependency tree built, 5 nodes to process"
  int32 nodes_total = 5;
}

// StopGoodsFactoryRequest stops a factory operation
message StopGoodsFactoryRequest {
  int32 player_id = 1;
  string factory_id = 2;
}

// StopGoodsFactoryResponse confirms factory stopped
message StopGoodsFactoryResponse {
  string factory_id = 1;
  string status = 2;
  string message = 3;
}

// GetFactoryStatusRequest retrieves factory status
message GetFactoryStatusRequest {
  int32 player_id = 1;
  string factory_id = 2;
}

// GetFactoryStatusResponse returns detailed factory status
message GetFactoryStatusResponse {
  string factory_id = 1;
  string target_good = 2;
  string status = 3;
  string dependency_tree = 4; // JSON-encoded dependency tree
  int32 quantity_acquired = 5; // 0 if not yet complete
  int32 total_cost = 6;
  int32 nodes_completed = 7;
  int32 nodes_total = 8;
  string system_symbol = 9;
  int32 ships_used = 10; // Number of ships utilized
  int32 market_queries = 11; // Number of market queries performed
  int32 parallel_levels = 12; // Number of parallel execution levels
  float estimated_speedup = 13; // Estimated speedup from parallelization
}
